---
prev: ./api.md
next: ./commands.md
---

# Фільтрування і `bot.on()`

Перший аргумент `bot.on()` — це текст, який називається _фільтром_.

## Вступ

Більшість (усі?) інших фреймворків для створення ботів дозволяють виконувати примітивну форму фільтрації оновлень: наприклад, тільки `on("message")` тощо.
Реалізація інших видів фільтрації повідомлень залишається за розробниками, що часто призводить до нескінченних операторів `if` у коді.

Однак **grammY постачається з власною мовою фільтрування**, яку ви можете використовувати, щоб **фільтрувати саме ті повідомлення**, які вам потрібні.

Це дозволяє використовувати понад 650-ти різних фільтрів, і з часом ми можемо додати більше.
Кожен дійсний фільтр може бути автоматично доповнений у вашому редакторі коду.
Отже, ви можете просто ввести `bot.on("")`, відкрити автодоповнення та шукати за всіма запитами, ввівши щось.

![Пошук фільтрів](/images/filter-query-search.png)

Визначення типу `bot.on()` охопить фільтр, який ви вибрали.
Таким чином, фільтр звузить кілька типів у контексті, які, як відомо, присутні в повідомленні.

```ts
bot.on("message", (ctx) => {
  // Може бути `undefined`, якщо отримане повідомлення не містить тексту.
  const text: string | undefined = ctx.msg.text;
});
bot.on("message:text", (ctx) => {
  // Текст завжди визначається, оскільки цей обробник викликається під час отримання текстового повідомлення.
  const text: string = ctx.msg.text;
});
```

У певному сенсі grammY реалізує фільтри як під час виконання, так і на рівні типів.

## Приклади фільтрів

Ось кілька прикладів фільтрів:

### Звичайні фільтри

Прості фільтри для оновлень і підфільтри:

```ts
bot.on("message"); // викликається при отриманні будь-якого повідомлення
bot.on("message:text"); // тільки текстові повідомлення
bot.on("message:photo"); // тільки фотоповідомлення
```

### Фільтр для сутностей

Підфільтри, які йдуть на один рівень глибше:

```ts
bot.on("message:entities:url"); // повідомлення, що містять URL
bot.on("message:entities:code"); // повідомлення, що містять фрагмент коду
bot.on("edited_message:entities"); // редаговані повідомлення з будь-якими сутностями
```

### Пропуск значень

Ви можете пропустити деякі значення у фільтрі.
grammY шукатиме різні значення, щоб відповідати вашому фільтру.

```ts
bot.on(":text"); // будь-які текстові повідомлення та будь-які текстові дописи на каналі
bot.on("message::url"); // повідомлення з URL-адресою в тексті або підписі: фотографії тощо
bot.on("::email"); // повідомлення або дописи на каналі з електронними листами в тексті або підписах
```

Якщо не вказати _перше_ значення, це відповідає повідомленням і дописам на каналі.
[Пам’ятайте](./context.md#%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%BD%D1%96-%D0%B4%D1%96%D1%96), що `ctx.msg` надає вам доступ до повідомлень та дописам на каналі, залежно від того, що відповідає фільтру.

Виключення _другого_ значення відповідає звичайним сутностям і сутностям підпису.
Ви можете виключити і перше, і друге значення одночасно.

### Скорочення

Механізм фільтрування grammY дозволяє визначати чіткі скорочення, які групують пов’язані фільтри.

#### `msg`

Скорочення `msg` групує нові повідомлення та нові дописи на каналі.
Іншими словами, використання `msg` еквівалентно прослуховуванню подій `"message"` і `"channel_post"`.

```ts
bot.on("msg"); // будь-яке повідомлення або допис на каналі
bot.on("msg:text"); // точно так само, як `:text`
```

#### `edit`

Скорочення `edit` групує редаговані повідомлення та редаговані дописи на каналі.

```ts
bot.on("edit"); // будь-які редаговані повідомлення або дописи на каналі
bot.on("edit:text"); // редаговані повідомлення з текстом
bot.on("edit::url"); // редаговані повідомлення з URL-адресою в тексті чи підписі
bot.on("edit:location"); // редаговані розташування
```

#### `:media`

Скорочення `:media` групує фото- та відеоповідомлення.

```ts
bot.on("message:media"); // фото- та відеоповідомлення
bot.on("edited_channel_post:media"); // редаговані дописи на каналі з фото або відео
bot.on(":media"); // фото- та відеоповідомлення або дописи на каналі
```

#### `:file`

Скорочення `:file` групує всі повідомлення, які містять файл.
Отже, ви можете бути впевнені, що `await ctx.getFile()` поверне об’єкт файлу.

```ts
bot.on(":file"); // повідомлення або дописи на каналі з файлами
bot.on("edit:file"); // редаговані повідомлення або дописи на каналі з файлами
```

### Синтаксичний цукор

Є два спеціальні випадки для частин фільтру, які роблять фільтрацію зручнішою.
Ви можете виявити ботів у фільтрах за допомогою частини фільтру `:is_bot`.
Синтаксичний цукор `:me` можна використовувати для посилання на вашого бота всередині фільтру, який порівнюватиме ідентифікатори користувачів за вас.

```ts
// Сервісне повідомлення про бота, який приєднався до чату
bot.on("message:new_chat_members:is_bot");
// Сервісне повідомлення про видалення вашого бота
bot.on("message:left_chat_member:me");
```

Зауважте, що хоча цей синтаксичний цукор корисний для роботи зі службовими повідомленнями, його не слід використовувати для виявлення того, чи хтось дійсно приєднується до чату чи залишає його.
Сервісні повідомлення - це повідомлення, які інформують користувачів у чаті, і деякі з них не завжди будуть видимі.
Наприклад, у великих групах не буде службових повідомлень про користувачів, які приєднуються до чату або залишають його.
Тому, ваш бот може цього не помітити.
Натомість вам варто стежити за [оновленнями учасників чату](#оновлення-учасників-чату).

## Поєднання кількох фільтрів

Ви можете комбінувати будь-яку кількість фільтрів з операціями І та АБО.

### Поєднання з АБО

Якщо ви хочете встановити якусь частину middleware за конкатенацією АБО двох фільтрів, ви можете передати обидва фільтри в `bot.on()` як масив.

```ts
// Запускається, якщо оновлення стосується повідомлення АБО редагованого повідомлення
bot.on(["message", "edited_message"] /* , ... */);
// Запускається, якщо в тексті чи підписі знайдено хештег АБО електронний лист АБО згадку
bot.on(["::hashtag", "::email", "::mention"] /* , ... */);
```

Middleware буде виконано, якщо _будь-який із наданих фільтрів_ збігається.
Порядок фільтрів не має значення.

### Поєднання з І

Якщо ви хочете встановити якусь частину middleware за конкатенацією І двох фільтрів, ви можете пов’язати виклики `bot.on()`.

```ts
// Збігається з пересланими URL-адресами
bot.on("::url").on(":forward_date" /* , ... */);
// Збігається з фотографіями, які містять хештег у підписі
bot.on(":photo").on("::hashtag" /* , ... */);
```

Middleware буде виконано, якщо _всі надані фільтри_ збігаються.
Порядок фільтрів не має значення.

### Побудова складних фільтрів

Технічно можливо об’єднати фільтри зі складнішими формулами, якщо вони знаходяться у [КНФ](https://uk.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BD%27%D1%8E%D0%BD%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0_%D0%BD%D0%BE%D1%80%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0_%D1%84%D0%BE%D1%80%D0%BC%D0%B0), хоча це навряд чи буде корисним.

```ts
bot
  // Збігається з усіма дописами на каналі або пересланими повідомленнями, ...
  .on(["channel_post", ":forward_date"])
  // ... які містять текст ...
  .on(":text")
  // ... принаймні з однією URL-адресою, хештегом або кештегом.
  .on(["::url", "::hashtag", "::cashtag"] /* , ... */);
```

Визначення типу `ctx` просканує весь ланцюжок викликів і перевірить кожен елемент усіх трьох викликів `.on`.
Наприклад, він може виявити, що `ctx.msg.text` є обов’язковою властивістю для наведеного вище фрагмента коду.

## Корисні поради

Ось деякі менш відомі функції фільтрів, які можуть стати в нагоді.
Деякі з них є трохи розвинутими теамми, тому можете сміливо переходити до [наступного розділу](./commands.md).

### Оновлення учасників чату

Ви можете використовувати наступний фільтр, щоб отримувати оновлення статусу свого бота.

```ts
bot.on("my_chat_member"); // start, stop, join або leave
```

У приватних чатах це спрацьовує, коли бот запускається або зупиняється.
У групах це спрацьовує, коли бот додається або видаляється.
Тепер ви можете перевірити `ctx.myChatMember`, щоб зрозуміти, що саме сталося.

Не плутайте це з

```ts
bot.on("chat_member");
```

який можна використовувати для визначення змін статусу інших учасників чату, коли люди приєднуються, підвищуються тощо.

> Зауважте, що оновлення `chat_member` потрібно ввімкнути явно, вказавши `allowed_updates` під час запуску бота.

### Комбінування фільтрів із іншими методами

Ви можете комбінувати фільтри з іншими методами класу `Composer` ([довідка API](https://deno.land/x/grammy/mod.ts?s=Composer)), такими як `command` або `filter`.
Це дозволяє створювати потужні шаблони обробки повідомлень.

```ts
bot.on(":forward_date").command("help"); // переслані команди /help

// Обробляємо команди лише в приватних чатах.
const pm = bot.chatType("private");
pm.command("start");
pm.command("help");
```

### Фільтрування за типом відправника повідомлення

Існує п’ять різних можливих типів авторів повідомлень у Telegram:

1. Автори дописів на каналі
2. Автоматичні переадресації з пов’язаних каналів у групах обговорення
3. Звичайні облікові записи користувачів, включаючи ботів. Тобто "звичайні" повідомлення
4. Адміністратори, які надсилають від імені групи ([анонімні адміністратори](https://telegram.org/blog/filters-anonymous-admins-comments#anonymous-group-admins))
5. Користувачі, які надсилають повідомлення як один зі своїх каналів

Ви можете комбінувати фільтри з іншими механізмами обробки оновлень, щоб дізнатися тип автора повідомлення.

```ts
// Дописи на каналі, надіслані `ctx.senderChat`
bot.on("channel_post");

// Автоматична переадресація з каналу `ctx.senderChat`
bot.on("message:is_automatic_forward");
// Звичайні повідомлення, надіслані `ctx.from`
bot.on("message").filter((ctx) => ctx.senderChat === undefined);
// Анонімний адмін у `ctx.chat`
bot.on("message").filter((ctx) => ctx.senderChat?.id === ctx.chat.id);
// Користувачі, які надсилають повідомлення від імені свого каналу `ctx.senderChat`
bot.on("message").filter((ctx) =>
  ctx.senderChat !== undefined && ctx.senderChat.id !== ctx.chat.id
);
```

### Фільтрування за властивостями користувача

Якщо ви хочете фільтрувати за іншими властивостями користувача, вам потрібно виконати додатковий запит: наприклад, `await ctx.getAuthor()` для отримання автора повідомлення.
Фільтри не будуть таємно виконувати подальші запити API для вас.
Виконати цей вид фільтрації все одно просто:

```ts
bot.on("message").filter(
  async (ctx) => {
    const user = await ctx.getAuthor();
    return user.status === "creator" || user.status === "administrator";
  },
  (ctx) => {
    // Обробляємо повідомлення від авторів і адміністраторів.
  },
);
```

### Повторне використання логіки фільтра

Всередині `bot.on` покладається на функцію під назвою `matchFilter`.
Він бере фільтр і компілює його до предикатної функції.
Предикат просто передається в `bot.filter` для фільтрації оновлень.

Ви можете імпортувати `matchFilter` напряму, якщо хочете використовувати його у власній логіці.
Наприклад, ви можете видалити всі оновлення, які відповідають певному фільтру:

```ts
// Видалити всі текстові повідомлення або текстові дописи на каналі.
bot.drop(matchFilter(":text"));
```

Аналогічно, ви можете використовувати типи фільтрів, які grammY використовує внутрішньо:

### Повторне використання типів фільтрів

Всередині `matchFilter` використовує [предикати типів](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates) TypeScript, щоб звузити тип `ctx`.
Він приймає тип `C extends Context` і `Q extends FilterQuery` і створює `ctx is Filter<C, Q>`.
Іншими словами, тип `Filter` — це те, що ви фактично отримуєте для вашого `ctx` у middleware.

Ви можете імпортувати `Filter` напряму, якщо хочете використовувати його у власній логіці.
Наприклад, ви можете визначити функцію обробки, яка обробляє певні об’єкти контексту, які були відфільтровані:

```ts
function handler(ctx: Filter<Context, ":text">) {
  // обробляємо звужений обʼєкт контексту
}

bot.on(":text", handler);
```

> Перегляньте довідку API для [`matchFilter`](https://deno.land/x/grammy/filter.ts?s=matchFilter), [`Filter`](https://deno.land/x/grammy /filter.ts?s=Filter) і [`FilterQuery`](https://deno.land/x/grammy/filter.ts?s=FilterQuery) для продовження читання.

## Мова фільтрування

> Цей розділ призначений для користувачів, які хочуть глибше зрозуміти фільтрування в grammY, але він не містить жодних знань, необхідних для створення бота.

### Структура фільтру

Кожен фільтр складається максимум з трьох частин.
Залежно від того, скільки частин містить фільтр, ми розрізняємо фільтри L1, L2 і L3, такі як `"message"`, `"message:entities"` і `"message:entities:url"` відповідно.

Частини фільтру розділені двокрапками (`:`).
Ми називаємо частину до першої двокрапки або кінця рядка _L1 частиною_ фільтру.
Ми називаємо частину від першої двокрапки до другої двокрапки або до кінця рядка _L2 частиною_ фільтру.
Ми називаємо частину від другої двокрапки до кінця рядка _L3 частиною_ фільтру.

Наприклад:

| Фільтр                       | L1 частина  | L2 частина   | L3 частина  |
| ---------------------------- | ----------- | ------------ | ----------- |
| `"message"`                  | `"message"` | `undefined`  | `undefined` |
| `"message:entities"`         | `"message"` | `"entities"` | `undefined` |
| `"message:entities:mention"` | `"message"` | `"entities"` | `"mention"` |

### Перевірка фільтру

Незважаючи на те, що система типів повинна перехоплювати всі недійсні фільтри під час компіляції, grammY також перевіряє всі передані фільтри під час виконання протягом налаштування.
Кожен переданий фільтр зіставляється зі структурою перевірки, яка перевіряє його дійсність.
Мало того, що непогано виходити з ладу відразу під час налаштування, а не під час виконання, раніше траплялося так, що помилки в TypeScript спричиняли серйозні проблеми зі складною системою виведення типів, яка забезпечує фільтри.
Якщо це повториться у майбутньому, це запобіжить проблемам, які могли б виникнути в іншому випадку.
У цьому випадку вам будуть надані корисні повідомлення про помилки.

### Продуктивність

**grammY може перевіряти кожен фільтр за амортизований постійний час на оновлення**, незалежно від структури фільтру чи вхідного оновлення.

Перевірка фільтрів відбувається лише один раз, коли бот ініціалізується та викликається `bot.on()`.

Під час запуску grammY отримує функцію предикату з фільтру, розділяючи його на частини фільтру.
Кожна частина буде зіставлена з функцією, яка виконує одну перевірку `in` або дві перевірки, якщо частину пропущено та потрібно перевірити два значення.
Потім ці функції об’єднуються, щоб сформувати предикат, який має лише перевіряти стільки значень, скільки відповідають фільтру, без повторення ключів об’єктів `Update`.

Ця система використовує менше операцій, ніж деякі конкуруючі бібліотеки, яким потрібно виконувати перевірки збереження в масивах під час маршрутизації оновлень.
Система фільтрації grammY набагато потужніша.
